name: X autopost (variable daily schedule)

on:
  schedule:
    - cron: "*/5 * * * *"   # 5分ごとに起動（UTC）。スクリプト内でJST扱い
  workflow_dispatch:        # 手動実行ボタンも有効に

concurrency:
  group: x-autopost-daily
  cancel-in-progress: false

permissions:
  contents: read   # checkout用（デフォルトでもOK）

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Tokyo
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps
        run: |
          npm init -y >/dev/null 2>&1
          npm i twitter-api-v2

      - name: Create script
        run: |
          cat > post.js <<'EOF'
          const { TwitterApi } = require('twitter-api-v2');

          // ---------- helpers ----------
          const SALT = process.env.SALT || 'soshi';
          function jstNow(){ return new Date(Date.now() + 9*3600*1000); }
          function pad2(n){ return String(n).padStart(2,'0'); }
          function ymdNum(d){ return Number(`${d.getUTCFullYear()}${pad2(d.getUTCMonth()+1)}${pad2(d.getUTCDate())}`); }

          // seeded PRNG
          function mulberry32(seed){ return function(){ let t=seed+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
          function hashStr(s){ let h=2166136261>>>0; for (let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }
          function rngForToday(){ const d=jstNow(); const seed=(ymdNum(d)^hashStr(SALT))>>>0; return mulberry32(seed); }
          function randInt(rng,a,b){ return Math.floor(rng()*(b-a+1))+a; }
          function padHHMM(h,m){ return `${pad2(h)}:${pad2(m)}`; }

          function slots5min(h1,h2){
            const out=[]; for(let h=h1; h<=h2; h++){ for(let m=0;m<60;m+=5) out.push(padHHMM(h,m)); }
            return out;
          }

          function triangularInt(rng,min,mode,max){
            const u=rng(), c=(mode-min)/(max-min); let val;
            if(u<c) val=min+Math.sqrt(u*(max-min)*(mode-min)); else val=max-Math.sqrt((1-u)*(max-min)*(max-mode));
            return Math.max(min, Math.min(max, Math.round(val)));
          }

          const nowJ = jstNow();
          const dow = nowJ.getUTCDay(); // 0=Sun
          const rng = rngForToday();

          const countToday = triangularInt(rng,17,22,27);
          const windows = [
            { name:'morning', range:[6,10],  base:0.9 },
            { name:'noon',    range:[11,15], base:1.1 },
            { name:'evening', range:[18,21], base:1.3 },
            { name:'late',    range:[22,23], base:0.5 },
          ].map(w => ({ ...w, base: w.base*( (dow===0||dow===6) ? 1.15 : 1 ) }));

          const totalW = windows.reduce((s,w)=>s+w.base,0);
          const alloc = windows.map(w=>({name:w.name, n: Math.floor(countToday*(w.base/totalW))}));
          let rem = countToday - alloc.reduce((s,a)=>s+a.n,0);
          while(rem-->0) alloc[randInt(rng,0,alloc.length-1)].n++;

          const selected = new Set();
          function pickSlots(range, n){
            const NEAR=new Set(); const pool=slots5min(range[0],range[1]);
            let tries=0;
            while(n>0 && tries<10000){
              tries++;
              const s = pool[randInt(rng,0,pool.length-1)];
              if(selected.has(s) || NEAR.has(s)) continue;
              const [H,M]=s.split(':').map(Number);
              for(let d=-2; d<=2; d++){
                const mm=(H*60+M)+d*5; if(mm<0||mm>=24*60) continue;
                const h2=Math.floor(mm/60), m2=mm%60; NEAR.add(padHHMM(h2,m2));
              }
              selected.add(s); n--;
            }
          }
          for(const a of alloc){ const w=windows.find(x=>x.name===a.name); pickSlots(w.range,a.n); }

          const curH = nowJ.getUTCHours(), curM = Math.floor(nowJ.getUTCMinutes()/5)*5;
          const CUR = padHHMM(curH,curM);
          if(!selected.has(CUR)){ console.log("skip", CUR, "target:", countToday, "picked:", selected.size); process.exit(0); }

          function choiceWeighted(rng, arr){ const sum=arr.reduce((s,i)=>s+i.w,0); let r=rng()*sum; for(const i of arr){ r-=i.w; if(r<=0) return i.v; } return arr[arr.length-1].v; }
          const theme = choiceWeighted(rng, [
            {v:'借金返済/マネー習慣', w:1.2},
            {v:'副業・小さな前進',   w:1.3},
            {v:'ゴルフ練習・気づき', w:0.9},
            {v:'サーフィン/海の感覚',w:0.7},
            {v:'釣り・自然',         w:0.6},
            {v:'生活の小ネタ',       w:0.8},
          ]);

          async function genWithOpenAI(){
            const system = [
              "あなたは30代の日本人。借金返済中だが前向き。",
              "副業やゴルフ/サーフィン/釣りの実感ベースで、",
              "X向けの自然な日本語ツイートを作る。",
              "140文字以内。ハッシュタグ禁止。絵文字は入れても1個まで。",
              "広告っぽさ/過度な断定/煽りはNG。出力は本文のみ。"
            ].join("");
            const user = `日本時間 ${pad2(nowJ.getUTCMonth()+1)}/${pad2(nowJ.getUTCDate())} ${pad2(curH)}:${pad2(curM)}ごろ。テーマは「${theme}」。体験っぽい一言＋小さな学びを1本。語尾やリズムは毎回変える。`;

            const resp = await fetch('https://api.openai.com/v1/chat/completions',{
              method:'POST',
              headers:{ 'Content-Type':'application/json', 'Authorization':`Bearer ${process.env.OPENAI_API_KEY}` },
              body: JSON.stringify({
                model:'gpt-4o-mini', temperature:0.9, presence_penalty:0.3, frequency_penalty:0.2, max_tokens:120,
                messages:[ {role:'system',content:system}, {role:'user',content:user} ]
              })
            });
            const json = await resp.json();
            if(!resp.ok) throw new Error(`OpenAI error: ${resp.status} ${JSON.stringify(json)}`);
            let text = (json.choices?.[0]?.message?.content || "").trim();
            text = text.replace(/#[\p{L}0-9_一-龥ー]+/gu,"").trim();
            const arr = Array.from(text); if(arr.length>140) text = arr.slice(0,140).join('');
            return text;
          }

          async function postToX(text){
            const client = new TwitterApi({
              appKey: process.env.X_CONSUMER_KEY,
              appSecret: process.env.X_CONSUMER_SECRET,
              accessToken: process.env.X_ACCESS_TOKEN,
              accessSecret: process.env.X_ACCESS_SECRET,
            });
            const r = await client.v2.tweet(text);
            return r?.data?.id;
          }

          (async()=>{
            try{
              const text = await genWithOpenAI();
              if(!text) throw new Error('empty text');
              const id = await postToX(text);
              console.log('posted', CUR, id, text);
            }catch(e){
              console.error('failed', e);
              process.exit(1);
            }
          })();
          EOF

      - name: Run poster
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          X_CONSUMER_KEY: ${{ secrets.X_CONSUMER_KEY }}
          X_CONSUMER_SECRET: ${{ secrets.X_CONSUMER_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_SECRET: ${{ secrets.X_ACCESS_SECRET }}
          SALT: ${{ secrets.SALT }}
        run: node post.js
